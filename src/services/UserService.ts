import axios from 'axios';
import type { User as AuthUser } from '../contexts/types';
import type { User as LegacyUser, UserCreateRequest, UserResponse } from '../Entities/User';

// URL base da API - deve corresponder ao backend .NET
const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'https://localhost:7102' || 'http://localhost:5079';

// Legacy API (para compatibilidade com SCRUM52)
const legacyApi = axios.create({
  baseURL: API_BASE_URL, // ou o endere√ßo onde est√° rodando o json-server
});

/* ===================================================================== */
/* INTERFACES E TIPOS                                                   */
/* ===================================================================== */

// Interface do usu√°rio simplificada (backend)
export interface User {
  id: number;
  name: string;
  email: string;
  role: string;
  phone?: string;
  document?: string;
  companyId?: number;
  isEmailConfirmed?: boolean;
  createdAt?: string;
  updatedAt?: string;
}

// Interface para cria√ß√£o de usu√°rio (com senha)
export interface CreateUserRequest {
  name: string;
  email: string;
  password: string;
  role?: string;
  phone?: string;
  document?: string;
  companyId?: number;
}

// Interface para atualiza√ß√£o de usu√°rio (sem senha)
export interface UpdateUserRequest {
  name?: string;
  email?: string;
  role?: string;
  phone?: string;
  document?: string;
  companyId?: number;
}

// Interface para login
export interface LoginRequest {
  email: string;
  password: string;
}

// Interface da resposta do backend (AppUserDto)
interface BackendUserDto {
  id: number;
  name: string;
  email: string;
  password: string;
  role: string;
  phone?: string;
  document?: string;
  companyId?: number;
  isEmailConfirmed?: boolean;
}

/* ===================================================================== */
/* FUN√á√ïES DE MAPEAMENTO E ADAPTA√á√ÉO                                     */
/* ===================================================================== */

// Mapeia dados do backend (AppUserDto) para o frontend (User)
const mapBackendToFrontend = (backendUser: BackendUserDto): User => {
  return {
    id: backendUser.id,
    name: backendUser.name,
    email: backendUser.email,
    role: backendUser.role || 'customer',
    phone: backendUser.phone,
    document: backendUser.document,
    companyId: backendUser.companyId,
    isEmailConfirmed: backendUser.isEmailConfirmed || false, // Mapeia do backend
  };
};

// Adapta User (backend) para AuthUser (contexto de autentica√ß√£o)
export const adaptUserToAuthUser = (user: User, existingData?: AuthUser): AuthUser => {
  return {
    id: user.id.toString(), // AuthUser usa string, User usa number
    name: user.name,
    email: user.email,
    role: user.role,
    isEmailConfirmed: user.isEmailConfirmed, // Mapeia o status de confirma√ß√£o de email
    avatar: `https://via.placeholder.com/150/007bff/fff?text=${user.name.charAt(0).toUpperCase()}`,
    // Preserva informa√ß√µes existentes ou usa padr√µes
    birthDate: existingData?.birthDate || '01/01/1990',
    cpf: existingData?.cpf || user.document || '000.000.000-00',
    gender: existingData?.gender || 'N√£o informado',
    phone: user.phone || existingData?.phone || '(00) 00000-0000',
    phone2: existingData?.phone2 || '(00) 00000-0000',
    memberSince: existingData?.memberSince || new Date().toLocaleDateString('pt-BR', { month: 'long', year: 'numeric' }),
    // Informa√ß√µes de endere√ßo preservadas ou padr√£o
    cep: existingData?.cep || '00000-000',
    street: existingData?.street || 'A definir',
    streetNumber: existingData?.streetNumber || '0',
    complement: existingData?.complement || '',
    neighborhood: existingData?.neighborhood || 'A definir',
    city: existingData?.city || 'A definir',
    state: existingData?.state || 'SP',
    country: existingData?.country || 'Brasil'
  };
};

/* ===================================================================== */
/* SERVI√áOS DE API                                                       */
/* ===================================================================== */

/**
 * Envia email de confirma√ß√£o para um usu√°rio rec√©m-registrado
 * @param userId - ID do usu√°rio para enviar o email de confirma√ß√£o
 * @returns Promise que resolve quando o email for enviado com sucesso
 */
export const sendEmailConfirmation = async (userId: number): Promise<void> => {
  try {
    console.log(`üîÑ Enviando email de confirma√ß√£o para o usu√°rio ID: ${userId}`);
    
    await axios.post(
      `${API_BASE_URL}/api/AppUser/send-confirmation-email/${userId}`
    );
    
    console.log('‚úÖ Email de confirma√ß√£o enviado com sucesso');
  } catch (error) {
    console.error('‚ùå Erro ao enviar email de confirma√ß√£o:', error);
    
    // Apenas logamos o erro, mas n√£o interrompemos o fluxo
    // para n√£o impedir o usu√°rio de continuar usando a aplica√ß√£o
    // se houver algum problema com o envio do email
  }
};

/**
 * Registra um novo usu√°rio no sistema
 * @param formData - Dados do usu√°rio para criar
 * @returns Promise com o usu√°rio criado ou erro
 */
export const createUser = async (formData: any) => {
  try {
    // Adapta o formato dos dados para o esperado pelo backend
    const appUserDto = {
      name: formData.name,
      email: formData.email,
      password: formData.password,
      role: "customer", // Papel padr√£o para novos usu√°rios
      phone: formData.phone,
      document: formData.document,
      // N√£o enviamos confirmPassword para o backend
    };
    
    console.log('üîÑ Enviando dados para cria√ß√£o de usu√°rio:', appUserDto);
    
    const response = await axios.post(`${API_BASE_URL}/api/AppUser/create`, appUserDto);
    return response.data;
  } catch (error) {
    if (axios.isAxiosError(error)) {
      // Deixa o tratamento na tela fazer o resto
      throw error;
    }

    // Se for outro erro (n√£o-Axios), lan√ßa um erro gen√©rico
    throw new Error('Erro inesperado ao registrar usu√°rio');
  }
};

/**
 * Busca usu√°rio por ID
 * @param id - ID do usu√°rio
 * @returns Promise com dados do usu√°rio
 */
export const getUserById = async (id: number): Promise<User> => {
  try {
    console.log(`üîÑ Buscando usu√°rio por ID: ${id}`);
    
    const response = await axios.get(
      `${API_BASE_URL}/api/AppUser/${id}`
    );

    console.log('üìã Resposta do getUserById:', response.data);
    console.log('‚úÖ Usu√°rio encontrado:', response.data.email);
    
    // Mapeia dados do backend para frontend
    return mapBackendToFrontend(response.data);
    
  } catch (error) {
    console.error('‚ùå Erro ao buscar usu√°rio por ID:', error);
    
    if (axios.isAxiosError(error)) {
      if (error.response?.status === 404) {
        throw new Error('Usu√°rio n√£o encontrado');
      }
      throw new Error(`Erro do servidor: ${error.response?.status}`);
    }
    
    throw new Error('Erro de conex√£o com o servidor');
  }
};

/**
 * Busca usu√°rio por email (para login)
 * @param email - Email do usu√°rio
 * @returns Promise com dados do usu√°rio ou null se n√£o encontrado
 */
export const getUserByEmail = async (email: string): Promise<User | null> => {
  try {
    console.log(`üîÑ Buscando usu√°rio por email: ${email}`);
    
    // Busca todos os usu√°rios e filtra por email
    // Nota: Idealmente o backend deveria ter um endpoint espec√≠fico para busca por email
    const response = await axios.get(
      `${API_BASE_URL}/api/AppUser`
    );

    console.log('üìã Resposta bruta do backend:', response.data);

    // O backend .NET retorna no formato ReferenceHandler.Preserve: {"$id":"1","$values":[...]}
    let usersList: BackendUserDto[];
    
    if (response.data && typeof response.data === 'object' && '$values' in response.data) {
      // Formato ReferenceHandler.Preserve
      usersList = response.data.$values;
      console.log(`‚úÖ Lista de usu√°rios (ReferenceHandler): Total: ${usersList.length}`);
    } else if (Array.isArray(response.data)) {
      // Formato array direto
      usersList = response.data;
      console.log(`‚úÖ Lista de usu√°rios (Array): Total: ${usersList.length}`);
    } else {
      console.error('‚ùå Formato de resposta inesperado:', response.data);
      throw new Error('Formato de resposta do servidor inv√°lido');
    }
    
    // Procura o usu√°rio com o email especificado
    const foundUser = usersList.find(user => user.email === email);
    
    if (foundUser) {
      console.log('‚úÖ Usu√°rio encontrado por email:', foundUser.email);
      return mapBackendToFrontend(foundUser);
    } else {
      console.log('‚ùå Usu√°rio n√£o encontrado por email');
      return null;
    }
    
  } catch (error) {
    console.error('‚ùå Erro ao buscar usu√°rio por email:', error);
    
    if (axios.isAxiosError(error)) {
      throw new Error(`Erro do servidor: ${error.response?.status}`);
    }
    
    throw new Error('Erro de conex√£o com o servidor');
  }
};

/**
 * Simula login verificando email e senha
 * Nota: Em produ√ß√£o, isso seria feito pelo backend com hash de senha
 * @param loginData - Dados de login (email e senha)
 * @returns Promise com dados do usu√°rio ou null se credenciais inv√°lidas
 */
export const loginUser = async (loginData: LoginRequest): Promise<User | null> => {
  try {
    console.log(`üîÑ Tentativa de login: ${loginData.email}`);
    
    // Busca o usu√°rio por email
    const user = await getUserByEmail(loginData.email);
    
    if (!user) {
      console.log('‚ùå Usu√°rio n√£o encontrado para login');
      return null;
    }

    // Nota: Em produ√ß√£o, a valida√ß√£o da senha seria feita pelo backend
    // Aqui estamos simulando que o login sempre √© bem-sucedido se o usu√°rio existe
    // Para implementar valida√ß√£o real, seria necess√°rio um endpoint /login no backend
    
    console.log('‚úÖ Login simulado bem-sucedido:', user.email);
    return user;
    
  } catch (error) {
    console.error('‚ùå Erro durante login:', error);
    throw error;
  }
};

/**
 * Busca todos os usu√°rios (para uso administrativo)
 * @returns Promise com lista de usu√°rios
 */
export const getAllUsers = async (): Promise<User[]> => {
  try {
    console.log('üîÑ Buscando todos os usu√°rios...');
    
    const response = await axios.get(
      `${API_BASE_URL}/api/AppUser`
    );

    console.log('üìã Resposta bruta do backend:', response.data);

    // O backend .NET retorna no formato ReferenceHandler.Preserve: {"$id":"1","$values":[...]}
    let usersList: BackendUserDto[];
    
    if (response.data && typeof response.data === 'object' && '$values' in response.data) {
      // Formato ReferenceHandler.Preserve
      usersList = response.data.$values;
      console.log(`‚úÖ Lista de usu√°rios (ReferenceHandler): Total: ${usersList.length}`);
    } else if (Array.isArray(response.data)) {
      // Formato array direto
      usersList = response.data;
      console.log(`‚úÖ Lista de usu√°rios (Array): Total: ${usersList.length}`);
    } else {
      console.error('‚ùå Formato de resposta inesperado:', response.data);
      throw new Error('Formato de resposta do servidor inv√°lido');
    }
    
    // Mapeia todos os usu√°rios do backend para frontend
    return usersList.map(mapBackendToFrontend);
    
  } catch (error) {
    console.error('‚ùå Erro ao buscar usu√°rios:', error);
    
    if (axios.isAxiosError(error)) {
      throw new Error(`Erro do servidor: ${error.response?.status}`);
    }
    
    throw new Error('Erro de conex√£o com o servidor');
  }
};

/**
 * Atualiza dados de um usu√°rio existente
 * @param id - ID do usu√°rio a ser atualizado
 * @param updateData - Dados a serem atualizados
 * @returns Promise com os dados atualizados do usu√°rio
 */
export const updateUser = async (id: number, updateData: UpdateUserRequest): Promise<User> => {
  try {
    console.log(`üîÑ Atualizando usu√°rio ID: ${id}`, updateData);
    
    // Primeiro, busca os dados atuais do usu√°rio para manter campos n√£o editados
    const currentUser = await getUserById(id);
    
    // Prepara dados para envio, mesclando dados atuais com atualiza√ß√µes
    const updatedData = {
      id,
      name: updateData.name ?? currentUser.name,
      email: updateData.email ?? currentUser.email,
      password: '', // O backend deve manter a senha atual se vazio
      role: updateData.role ?? currentUser.role,
      phone: updateData.phone ?? currentUser.phone,
      document: updateData.document ?? currentUser.document,
      companyId: updateData.companyId ?? currentUser.companyId,
    };

    console.log('üì§ Dados sendo enviados para atualiza√ß√£o:', updatedData);
    
    // Faz a requisi√ß√£o PUT para atualizar usu√°rio
    const response = await axios.put(
      `${API_BASE_URL}/api/AppUser/${id}`,
      updatedData,
      {
        headers: {
          'Content-Type': 'application/json',
        },
      }
    );

    console.log('üìã Resposta da atualiza√ß√£o:', response.data);
    console.log('‚úÖ Usu√°rio atualizado com sucesso');

    // Busca os dados atualizados do usu√°rio
    const updatedUser = await getUserById(id);
    return updatedUser;
    
  } catch (error) {
    console.error('‚ùå Erro ao atualizar usu√°rio:', error);
    
    if (axios.isAxiosError(error)) {
      if (error.response?.status === 404) {
        throw new Error('Usu√°rio n√£o encontrado');
      }
      if (error.response?.status === 400) {
        throw new Error('Dados inv√°lidos fornecidos');
      }
      if (error.response?.status === 409) {
        throw new Error('Email j√° est√° em uso por outro usu√°rio');
      }
      throw new Error(`Erro do servidor: ${error.response?.status}`);
    }
    
    throw new Error('Erro de conex√£o com o servidor');
  }
};

/**
 * Deleta um usu√°rio do sistema
 * @param id - ID do usu√°rio a ser deletado
 * @returns Promise<boolean> - true se a opera√ß√£o foi bem-sucedida
 */
export const deleteUser = async (id: number): Promise<boolean> => {
  try {
    console.log(`üîÑ Deletando usu√°rio ID: ${id}`);
    
    const response = await axios.delete(`${API_BASE_URL}/api/AppUser/${id}`);
    console.log('‚úÖ Usu√°rio deletado com sucesso');
    return response.status === 200 || response.status === 204;
  } catch (error) {
    console.error('Error deleting user:', error);
    return false;
  }
};

/**
 * Reenvia o email de confirma√ß√£o para o usu√°rio
 * @param userId O ID do usu√°rio
 * @returns true se o reenvio foi bem-sucedido, false caso contr√°rio
 */
export const resendEmailConfirmation = async (userId: number): Promise<boolean> => {
  try {
    const response = await axios.post(`${API_BASE_URL}/api/AppUser/send-confirmation-email/${userId}`);
    return response.status === 200;
  } catch (error) {
    console.error('Erro ao reenviar email de confirma√ß√£o:', error);
    return false;
  }
};

/**
 * Verifica o status atual de confirma√ß√£o de email de um usu√°rio
 * @param userId O ID do usu√°rio
 * @returns true se o email estiver confirmado, false caso contr√°rio
 */
export const checkEmailConfirmationStatus = async (userId: number): Promise<boolean> => {
  try {
    console.log(`üîÑ Verificando status de confirma√ß√£o de email para usu√°rio ${userId}`);
    
    const user = await getUserById(userId);
    
    console.log(`‚úÖ Status de confirma√ß√£o obtido: ${user.isEmailConfirmed ?? false}`);
    return user.isEmailConfirmed ?? false;
  } catch (error) {
    console.error('‚ùå Erro ao verificar status de confirma√ß√£o:', error);
    return false;
  }
};

/**
 * Confirma o email do usu√°rio usando o token de confirma√ß√£o
 * @param token O token de confirma√ß√£o de email
 * @returns true se a confirma√ß√£o foi bem-sucedida, false caso contr√°rio
 */
export const confirmEmail = async (token: string): Promise<boolean> => {
  try {
    console.log('üîÑ Enviando requisi√ß√£o GET para:', `${API_BASE_URL}/api/AppUser/confirm-email?token=${token}`);
    console.log('üìù Token enviado:', token);
    
    const response = await axios.get(`${API_BASE_URL}/api/AppUser/confirm-email?token=${encodeURIComponent(token)}`);
    
    console.log('‚úÖ Resposta recebida:', response.status, response.data);
    return response.status === 200;
  } catch (error: any) {
    console.error('‚ùå Erro ao confirmar email:', error);
    
    if (error.response) {
      console.error('üìã Detalhes do erro:');
      console.error('  - Status:', error.response.status);
      console.error('  - Data:', error.response.data);
      console.error('  - Headers:', error.response.headers);
    } else if (error.request) {
      console.error('üì° Sem resposta do servidor:', error.request);
    } else {
      console.error('‚öôÔ∏è Erro na configura√ß√£o da requisi√ß√£o:', error.message);
    }
    
    return false;
  }
};

/**
 * Solicita a recupera√ß√£o de senha enviando o email para o backend
 * @param email O email do usu√°rio que deseja recuperar a senha
 * @returns true se a solicita√ß√£o foi bem-sucedida, false caso contr√°rio
 */
export const requestPasswordReset = async (email: string): Promise<boolean> => {
  try {
    const response = await axios.post(`${API_BASE_URL}/api/AppUser/request-password-reset`, { email });
    return response.status === 200;
  } catch (error) {
    console.error('Erro ao solicitar recupera√ß√£o de senha:', error);
    return false;
  }
};

/**
 * Redefine a senha do usu√°rio usando o token de recupera√ß√£o
 * @param newPassword A nova senha do usu√°rio
 * @param token O token de recupera√ß√£o de senha
 * @returns true se a redefini√ß√£o foi bem-sucedida, false caso contr√°rio
 */
export const resetPassword = async (newPassword: string, token: string): Promise<boolean> => {
  try {
    // Verifica se os par√¢metros obrigat√≥rios foram fornecidos
    if (!newPassword || !token) {
      console.error('Par√¢metros obrigat√≥rios ausentes para redefini√ß√£o de senha');
      return false;
    }

    console.log('Enviando requisi√ß√£o para reset de senha com token:', 
      token ? `${token.substring(0, 10)}...` : 'vazio');

    // Chamada √† API para redefinir a senha com o formato correto
    const response = await axios.post(`${API_BASE_URL}/api/AppUser/reset-password`, {
      token,
      newPassword
    });
    
    console.log('Resposta do reset de senha:', response.status);
    
    // Verifique o status da resposta e retorne true se for bem-sucedido
    return response.status === 200 || response.status === 204;
  } catch (error: any) {
    // Log detalhado do erro para facilitar a depura√ß√£o
    console.error('Erro ao redefinir senha:', error);
    
    if (error.response) {
      // O servidor respondeu com um status de erro
      console.error('Status do erro:', error.response.status);
      console.error('Dados do erro:', error.response.data);
    } else if (error.request) {
      // A requisi√ß√£o foi feita mas n√£o houve resposta (problemas de rede)
      console.error('Sem resposta do servidor:', error.request);
    } else {
      // Erro ao configurar a requisi√ß√£o
      console.error('Erro na configura√ß√£o da requisi√ß√£o:', error.message);
    }
    
    return false;
  }
};

/* ===================================================================== */
/* FUN√á√ïES LEGADAS DO SCRUM52 (COMPATIBILIDADE)                          */
/* ===================================================================== */

/**
 * Vers√£o legada de cria√ß√£o de usu√°rio para compatibilidade com SCRUM52
 */
export const createLegacyUser = async (user: Omit<UserCreateRequest, 'createdAt' | 'updatedAt' | 'id'>): Promise<LegacyUser> => {
  const response = await legacyApi.post('/Users', user);
  return response.data;
};

/**
 * Vers√£o legada de busca de usu√°rio por email para compatibilidade com SCRUM52
 */
export const getLegacyUserByEmail = async (email: string): Promise<UserResponse | null> => {
  try {
    const response = await legacyApi.get<UserResponse[]>(`/Users?email=${encodeURIComponent(email)}`);
    return response.data.length > 0 ? response.data[0] : null;
  } catch (error) {
    console.error('Error fetching user by email:', error);
    return null;
  }
};

/**
 * Vers√£o legada de busca de todos os usu√°rios para compatibilidade com SCRUM52
 */
export const getAllLegacyUsers = async (): Promise<UserResponse[]> => {
  try {
    const response = await legacyApi.get<UserResponse[]>('/Users');
    return response.data;
  } catch (error) {
    console.error('Error fetching all users:', error);
    return [];
  }
};

/**
 * Vers√£o legada de busca de usu√°rio por ID para compatibilidade com SCRUM52
 */
export const getLegacyUserById = async (id: number): Promise<UserResponse | null> => {
  try {
    const response = await legacyApi.get<UserResponse>(`/Users/${id}`);
    return response.data;
  } catch (error) {
    console.error('Error fetching user by ID:', error);
    return null;
  }
};

/**
 * Vers√£o legada de atualiza√ß√£o de usu√°rio para compatibilidade com SCRUM52
 */
export const updateLegacyUser = async (id: number, user: Partial<Omit<LegacyUser, 'id' | 'createdAt' | 'updatedAt'>>): Promise<LegacyUser | null> => {
  try {
    const response = await legacyApi.put<LegacyUser>(`/Users/${id}`, user);
    return response.data;
  } catch (error) {
    console.error('Error updating user:', error);
    return null;
  }
};

/**
 * Vers√£o legada de remo√ß√£o de usu√°rio para compatibilidade com SCRUM52
 */
export const deleteLegacyUser = async (id: number): Promise<void> => {
  try {
    await legacyApi.delete(`/Users/${id}`);
  } catch (error) {
    console.error('Error deleting user:', error);
  }
};

// Exporta√ß√µes para compatibilidade
export { createUser as default };

